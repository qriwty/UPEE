
### Стратегія «розділяй та володарюй» та приклади застосування

**Стратегія «розділяй та володарюй» (Divide and Conquer)** - це метод розробки алгоритмів, який передбачає поділ проблеми на кілька підпроблем, розв'язання кожної підпроблеми окремо, а потім об'єднання результатів для отримання розв'язку вихідної проблеми.

#### Основні етапи стратегії:
1. **Розділення**: розбити початкову проблему на підпроблеми.
2. **Розв'язання**: розв'язати кожну підпроблему рекурсивно або ітеративно.
3. **Об'єднання**: об'єднати результати підпроблем для отримання розв'язку вихідної проблеми.

#### Приклади застосування:
- **Сортування злиттям (Merge Sort)**: поділ масиву на половини, сортування кожної половини і об'єднання відсортованих частин. Часова складність: O(n log n).
- **Швидке сортування (Quick Sort)**: вибір опорного елемента, розподіл елементів на менші і більші від опорного, рекурсивне сортування підмасивів. Часова складність: O(n log n) в середньому випадку.
- **Бінарний пошук (Binary Search)**: пошук елемента в відсортованому масиві шляхом поділу масиву на половини. Часова складність: O(log n).

### Стратегія балансування та приклади застосування

**Стратегія балансування** - це метод, який полягає в підтримці збалансованості структури даних для забезпечення ефективного доступу та модифікації даних.

#### Основні концепції:
1. **Балансування дерев**: підтримка висоти дерева в межах логарифмічного зростання, що забезпечує ефективні операції пошуку, вставки та видалення.
2. **Балансування навантаження**: розподіл обчислювальних ресурсів або завдань між декількома виконавцями для забезпечення ефективного виконання.

#### Приклади застосування:
- **AVL-дерева**: самобалансуючі двійкові дерева пошуку, де різниця висот піддерев будь-якого вузла не перевищує одного. Часова складність: O(log n) для вставки, видалення і пошуку.
- **Червоний-чорний дерева (Red-Black Trees)**: самобалансуючі двійкові дерева пошуку, які підтримують баланс шляхом додавання додаткового бітового атрибута для кожного вузла. Часова складність: O(log n) для вставки, видалення і пошуку.
- **Хешування з балансуванням навантаження**: використання хеш-таблиць для зберігання даних з балансуванням навантаження між сегментами. Часова складність: O(1) в середньому випадку для вставки, видалення і пошуку.

### Динамічне програмування та приклади застосування

**Динамічне програмування (Dynamic Programming)** - це метод розробки алгоритмів, який полягає у розв'язанні складних задач шляхом розбиття їх на підзадачі і збереження результатів розв'язання підзадач для уникнення повторних обчислень.

#### Основні концепції:
1. **Запам'ятовування (Memoization)**: збереження результатів підзадач у таблиці для уникнення повторних обчислень.
2. **Побудова таблиці**: заповнення таблиці розв'язками підзадач в певному порядку для отримання розв'язку вихідної задачі.

#### Приклади застосування:
- **Задача про рюкзак (Knapsack Problem)**: оптимізація вибору предметів для максимізації вартості при обмеженні на вагу. Часова складність: O(nW), де n - кількість предметів, W - місткість рюкзака.
- **Задача про найдовшу спільну підпослідовність (Longest Common Subsequence)**: знаходження найдовшої послідовності, яка є підпослідовністю двох заданих послідовностей. Часова складність: O(mn), де m і n - довжини двох послідовностей.
- **Задача про найкоротший шлях (Shortest Path Problem)**: знаходження найкоротшого шляху між двома вершинами в графі. Алгоритм Беллмана-Форда. Часова складність: O(VE), де V - кількість вершин, E - кількість ребер.

### Оцінювання складності алгоритму під час застосування кожної стратегії

#### Стратегія «розділяй та володарюй»
- **Часова складність**: залежить від кількості підзадач, їхнього розміру і часу об'єднання. Для алгоритмів з поділом навпіл і лінійним об'єднанням: O(n log n).
- **Просторова складність**: залежить від глибини рекурсії і додаткових даних, що зберігаються. Для алгоритмів з поділом навпіл: O(log n) додаткової пам'яті для рекурсії.

#### Стратегія балансування
- **Часова складність**: залежить від підтримки балансу. Для збалансованих дерев: O(log n) для основних операцій.
- **Просторова складність**: залежить від структури даних. Для збалансованих дерев: O(n) для зберігання даних і атрибутів балансу.

#### Динамічне програмування
- **Часова складність**: залежить від кількості підзадач і часу обчислення кожної підзадачі. Зазвичай: O(n^2) або O(nW) для задач з таблицею розміром n на W.
- **Просторова складність**: залежить від розміру таблиці для зберігання результатів підзадач. Зазвичай: O(n) або O(nW) для задач з таблицею розміром n на W.