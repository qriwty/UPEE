
### Стратегії пошуку у просторі станів

#### Пошук вшир (Breadth-First Search, BFS)
**Пошук вшир** - це алгоритм пошуку, який починається з початкового вузла і досліджує всі сусідні вузли на поточному рівні перед переходом до вузлів на наступному рівні. Використовується черга (FIFO) для зберігання вузлів, що підлягають обробці. Це гарантує, що алгоритм знайде найкоротший шлях у невзважених графах.

**Основні етапи алгоритму BFS**:
1. Додаємо початковий вузол до черги.
2. Виймаємо вузол з черги та перевіряємо, чи це цільовий вузол.
3. Якщо це цільовий вузол, завершуємо пошук.
4. Якщо це не цільовий вузол, додаємо всі його сусідні вузли до черги.
5. Повторюємо кроки 2-4, поки черга не стане порожньою або цільовий вузол не буде знайдено.

**Переваги BFS**:
- Гарантує знаходження найкоротшого шляху в невзважених графах.
- Підходить для пошуку в широку область навколо початкового вузла.

**Недоліки BFS**:
- Споживає велику кількість пам'яті для зберігання черги вузлів.
- Неефективний у графах з великою кількістю вузлів і ребер.

#### Пошук вглиб (Depth-First Search, DFS)
**Пошук вглиб** - це алгоритм пошуку, який досліджує якомога глибше кожну гілку перед поверненням назад. Використовується стек (LIFO) для зберігання вузлів, що підлягають обробці. Це дозволяє алгоритму досліджувати глибокі шляхи перш, ніж переходити до сусідніх вузлів.

**Основні етапи алгоритму DFS**:
1. Додаємо початковий вузол до стека.
2. Виймаємо вузол зі стека та перевіряємо, чи це цільовий вузол.
3. Якщо це цільовий вузол, завершуємо пошук.
4. Якщо це не цільовий вузол, додаємо всі його сусідні вузли до стека.
5. Повторюємо кроки 2-4, поки стек не стане порожнім або цільовий вузол не буде знайдено.

**Переваги DFS**:
- Споживає менше пам'яті порівняно з BFS.
- Підходить для задач, де потрібно дослідити всі можливі шляхи.

**Недоліки DFS**:
- Може застрягнути в глибоких і довгих шляхах.
- Не гарантує знаходження найкоротшого шляху.

#### Прямий пошук (Forward Search)
**Прямий пошук** - це метод, при якому пошук починається з початкового стану і рухається вперед до цільового стану. Використовується для задач, де відомі оператори, що переводять систему з одного стану в інший.

**Основні етапи прямого пошуку**:
1. Вибираємо початковий стан.
2. Застосовуємо оператори для переходу до нових станів.
3. Перевіряємо, чи досягнуто цільовий стан.
4. Повторюємо кроки 2-3, поки не буде досягнуто цільовий стан або не закінчаться оператори.

**Переваги прямого пошуку**:
- Легко реалізується для простих задач.
- Інтуїтивно зрозумілий метод.

**Недоліки прямого пошуку**:
- Може бути неефективним для складних задач з великою кількістю станів.
- Може вимагати великої кількості обчислень.

#### Зворотний пошук (Backward Search)
**Зворотний пошук** - це метод, при якому пошук починається з цільового стану і рухається назад до початкового стану. Використовується для задач, де відомі зворотні оператори, що переводять систему з одного стану в інший.

**Основні етапи зворотного пошуку**:
1. Вибираємо цільовий стан.
2. Застосовуємо зворотні оператори для переходу до нових станів.
3. Перевіряємо, чи досягнуто початковий стан.
4. Повторюємо кроки 2-3, поки не буде досягнуто початковий стан або не закінчаться зворотні оператори.

**Переваги зворотного пошуку**:
- Легко реалізується для простих задач.
- Інтуїтивно зрозумілий метод.

**Недоліки зворотного пошуку**:
- Може бути неефективним для складних задач з великою кількістю станів.
- Може вимагати великої кількості обчислень.

#### Двонаправлений пошук (Bidirectional Search)
**Двонаправлений пошук** - це метод, який одночасно проводить два пошуки: один від початкового стану і один від цільового стану, доки обидва пошуки не зустрінуться. Ця стратегія може значно зменшити кількість оброблюваних вузлів.

**Основні етапи двонаправленого пошуку**:
1. Починаємо пошук з початкового стану.
2. Починаємо пошук з цільового стану.
3. Переходимо від одного стану до іншого в обох пошуках.
4. Перевіряємо, чи зустрілися обидва пошуки.
5. Повторюємо кроки 3-4, поки обидва пошуки не зустрінуться.

**Переваги двонаправленого пошуку**:
- Значно зменшує кількість оброблюваних вузлів.
- Підходить для задач з великою кількістю станів.

**Недоліки двонаправленого пошуку**:
- Вимагає більш складної реалізації та управління двома пошуками.
- Потребує більше пам'яті для зберігання двох множин станів.

### Моделі подання знань

#### Семантична мережа (Semantic Network)
**Семантична мережа** - це графічне представлення знань, де вершини представляють концепти, а ребра - відношення між ними. Використовується для моделювання ієрархій, класів, підкласів, атрибутів і взаємозв'язків між об'єктами.

**Основні компоненти семантичної мережі**:
- **Вершини**: представляють об'єкти або поняття.
- **Ребра**: представляють відношення між об'єктами або поняттями.

**Приклади відношень в семантичній мережі**:
- **"Є підвидом"**: зв'язок між класами та підкласами.
- **"Має властивість"**: зв'язок між об'єктами та їх атрибутами.
- **"Відноситься до"**: зв'язок між об'єктами.

**Переваги семантичної мережі**:
- Візуальне представлення знань, що полегшує розуміння.
- Можливість моделювання складних взаємозв'язків між об'єктами.

**Недоліки семантичної мережі**:
- Може стати надто складною для великих наборів знань.
- Важко автоматизувати обробку великих мереж.

#### Продукційна модель (Production Model)
**Продукційна модель** - це набір правил "якщо-то", що визначають дії, які слід виконати в конкретних умовах. Правила складаються з умовної частини (якщо) і виконавчої частини (то).

**Основні компоненти продукційної моделі**:
- **Умовна частина (якщо)**: описує умови, за яких правило спрацьовує.
- **Виконавча частина (то)**: описує дії, які виконуються, коли правило спрацьовує.

**Приклад продукційного правила**:
- **"Якщо температура > 30°C, то включити кондиціонер"**

**Переваги продукційної моделі**:
- Легко зрозуміти та реалізувати.
- Підходить для автоматизації процесів та прийняття рішень.

**Недоліки продукційної моделі**:
- Може вимагати великої кількості правил для складних задач.
- Важко керувати та підтримувати велику кількість правил.